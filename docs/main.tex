\documentclass[12pt]{article}
\usepackage{graphicx} 
\usepackage{wrapfig}

\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{tcolorbox}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usepackage{bbm}
\usepackage{caption}

\usepackage{amsopn}

\usepackage{float}    
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Special Lecture on Computer Science III - Final Report},
    pdfpagemode=FullScreen,
    }
    
\usepackage{listings}

\usepackage[a4paper,top=2cm,bottom=2cm,left=1.75cm,right=1.55cm,marginparwidth=1.75cm]{geometry}

\title{Special Lecture on Computer Science III - Final Report}
\author{GILLARD Antonino Yann William \\ Student ID : 48-259744}
\date{January 2026}

\begin{document}

\maketitle

\tableofcontents

\newpage
\section{Introduction}
\noindent
The N-queens problem is a famous optimization problem. Let $N\in\mathbb{N}$. We consider a chess board of size $N \times N$. We want to 
place $N$ queen pieces on the board such that they cannot attack one another. In chess, a queen can attack pieces which are on the same row,
column or diagonal as itself. For example, here is a solution of $N$-queens problem for $N=8$.
\begin{center}
    \includegraphics[width=0.25\textwidth]{ressources/n-queen.png}
\captionof{figure}{A solution to the N-queens problem for $N=8$}
\end{center}

\noindent In this class, we have already seen methods on how to tackle that problem. In this report, we will solve that
problem with two different models : 
\begin{itemize}
    \item a constraint programming model using only boolean variables and pseudo boolean constraints,
    \item a QUBO model.
\end{itemize}
\noindent
In order to compare the performance of these two models we will use the MiniZinc Model given in Lecture 3 as a baseline.
Instead of using boolean variable, it used $N$ integer variables of value in $\llbracket 1, N\rrbracket$.

\section{Model 1 - Using boolean variables}

\subsection{Modeling}
In this section, we model our board with $N^2$ boolean variables such that : 
\begin{align*}
    \forall i \in \llbracket 1, N \rrbracket \quad
    \forall j \in \llbracket 1, N \rrbracket \quad
x_{i,j} =
\begin{cases}
1,   & \text{if a queen is present on tile }\left( i,j \right), \\
0,  & \text{otherwise}.
\end{cases}
\end{align*}

\noindent Now that we have our board, we can use the rules of chess to define our constraints.
Queens can attack pieces on the same row and  on the same column, meaning that we can only have 1 queen per row and one queen per column.
As such, we have the following constraints : 
\begin{align*}
    &\forall i \in \llbracket 1, N \rrbracket \quad \sum_{j=1}^{N} x_{i,j} = 1, \quad \text{(column constraints)} \\
    &\forall j \in \llbracket 1, N \rrbracket \quad \sum_{i=1}^{N} x_{i,j} = 1,  \quad \text{(row constraints)}
\end{align*}

\newpage
These 2 constraints also include the constraint that there must be $N$ queens placed on the board. Finally, we add the constraints on the diagonals. There must be at most a queen per diagonal.
\begin{align*}
    &\forall d \in \llbracket 0, N-1 \rrbracket \quad 
    \sum_{k=0}^{N-d-1} x_{1+k, 1+k+d} \leq 1, \\
    &\forall d \in \llbracket 1, N-1 \rrbracket \quad 
    \sum_{k=0}^{N-d-1} x_{1+k+d, 1+k} \leq 1, \\
    &\text{(top left to bottom right diagonals)}\\
    &\forall d \in \llbracket 0, N-1 \rrbracket \quad 
    \sum_{k=0}^{N-d-1} x_{N-d-k,1+k} \leq 1, \\
    &\forall d \in \llbracket 1, N-1 \rrbracket \quad 
    \sum_{k=0}^{N-d-1} x_{N-k,1+d+k} \leq 1, \\
    &\text{(bottom left to top right diagonals)}
\end{align*}

\subsection{Implementation}
Translating these constraints into MiniZinc gives us : 

\begin{quote}
\begin{verbatim}
% Size of board
int: N = 10;

% Board variables
array[1..N, 1..N] of var 0..1: positions;

% 1 queen per row / column
constraint forall (i in 1..N) 
    (sum (j in 1..N) (positions[i, j]) == 1);
constraint forall (j in 1..N) 
    (sum (i in 1..N) (positions[i, j]) == 1);

% Diagonal constraints
constraint forall (d in 0..(N-1)) 
    (sum (k in 0..(N-d-1)) ( positions[1+k, 1+k+d]  ) <= 1);
constraint forall (d in 1..(N-1)) 
    (sum (k in 0..(N-d-1)) ( positions[1+k+d, 1+k]  ) <= 1);
constraint forall (d in 0..(N-1)) 
    (sum (k in 0..(N-d-1)) ( positions[N-d-k, 1+k]  ) <= 1);
constraint forall (d in 1..(N-1)) 
    (sum (k in 0..(N-d-1)) ( positions[N-k, 1+k+d]  ) <= 1);

solve satisfy;
 
output [show2d(positions)];
\end{verbatim}
\end{quote}

\newpage
\subsection{Results}
To properly evaluate our program, we remove the command which prints the solution. By performing subsequent execution, we have the following execution times : 
\begin{center}
    \includegraphics[width=0.5\textwidth]{ressources/minizinc_data.png}
    \captionof{figure}{Execution time of the boolean variable MiniZinc model for different values of $N$}
\end{center}

We could have expected, an exponential growth of the execution times as $N$ grows larger. Although, it is not obvious in this graph,
the execution time for $N=26$ takes way longer than the one for $N=25$ (more than 10s). 
It can also be interesting to note that the times for $N=1, 5 \text{and} 10$ are similar (approximately 300ms). 
We expect from a well defined model and a good solver that the case $N=1$ be done as fast as possible. 
In the case $N=1$, compile time is almost all of the execution time. The compilation reduces the program down to :
\begin{quote}
    \begin{verbatim}    
        solve  satisfy;
    \end{verbatim}
\end{quote} 
Thus, we can observe that solving the N-queens problem with this model in MiniZinc for $N \leq 10$ gives us times similar to executing a trivial
problem. The great increase in execution time for greater values of $N$ may be caused by the complexity of the problem who grows exponentially but 
also perhaps because we have $N^2$ variables. As the number of constraints for each variable increases with greater values of $N$, having a model 
with $N^2$ may make things worse for the execution time.

\section{Model 2 - QUBO}
\subsection{Formal definition}

Since we are already working with boolean variables, we keep the earlier model for
our QUBO model. We now need to translate the constraints into an objective loss to
minimize.

\noindent The following constraints 
\begin{align*}
    &\forall i \in \llbracket 1, N \rrbracket \quad \sum_{j=1}^{N} x_{i,j} = 1, 
    \quad \forall j \in \llbracket 1, N \rrbracket \quad \sum_{i=1}^{N} x_{i,j} = 1, \\
\end{align*}
translate to adding 
\begin{align*}
    &- \sum_{i=1}^{N} \left( \sum_{j=1}^{N} x_{i,j} + 2 \sum_{k < l}^{N} x_{i,k} x_{i,l} \right) \text{and}
    - \sum_{j=1}^{N} \left( \sum_{i=1}^{N} x_{i,j} + 2 \sum_{k < l}^{N} x_{k,j} x_{l,j} \right),
\end{align*}
to the loss function. The diagonal constraints
\begin{align*}
    &\forall d \in \llbracket 0, N-1 \rrbracket \quad 
    \sum_{k=0}^{N-d-1} x_{1+k, 1+k+d} \leq 1, \quad \forall d \in \llbracket 1, N-1 \rrbracket \quad 
    \sum_{k=0}^{N-d-1} x_{1+k+d, 1+k} \leq 1, \\
    &\forall d \in \llbracket 0, N-1 \rrbracket \quad 
    \sum_{k=0}^{N-d-1} x_{N-d-k,1+k} \leq 1, \quad \forall d \in \llbracket 1, N-1 \rrbracket \quad 
    \sum_{k=0}^{N-d-1} x_{N-k,1+d+k} \leq 1, \\
\end{align*}
translate to 
\begin{align*}
    &\sum_{d=0}^{N-1} \left(
        \sum_{0\leq k < l < N - d - 1} x_{1+k+d, 1+k} \quad x_{1+l+d, 1+l}
    \right), \quad 
    \sum_{d=1}^{N-1} \left(
        \sum_{0\leq k < l < N - d - 1} x_{1+k, 1+k+d} \quad x_{1+k, 1+l+d}
    \right), \\
    &\sum_{d=0}^{N-1} \left(
        \sum_{0\leq k < l < N - d - 1} x_{N-d-k, 1+k} \quad x_{N-d-l, 1+l}
    \right), \quad
    \sum_{d=1}^{N-1} \left(
        \sum_{0\leq k < l < N - d - 1} x_{N-k, 1+d+k} \quad x_{N-l, 1+d+l}
    \right)
\end{align*}
Thus, the final loss function is 
\begin{align*}
    L = &- \sum_{i=1}^{N} \left( \sum_{j=1}^{N} x_{i,j} + 2 \sum_{k < l}^{N} x_{i,k} x_{i,l} \right) 
    - \sum_{j=1}^{N} \left( \sum_{i=1}^{N} x_{i,j} + 2 \sum_{k < l}^{N} x_{k,j} x_{l,j} \right) \\
    &+ \sum_{d=0}^{N-1} \left(
        \sum_{0\leq k < l < N - d - 1} x_{1+k+d, 1+k} \quad x_{1+l+d, 1+l}
    \right) 
    + \sum_{d=1}^{N-1} \left(
        \sum_{0\leq k < l < N - d - 1} x_{1+k, 1+k+d} \quad x_{1+k, 1+l+d}
    \right) \\ 
    &+ \sum_{d=0}^{N-1} \left(
        \sum_{0\leq k < l < N - d - 1} x_{N-d-k, 1+k} \quad x_{N-d-l, 1+l}
    \right)  
    + \sum_{d=1}^{N-1} \left(
        \sum_{0\leq k < l < N - d - 1} x_{N-k, 1+d+k} \quad x_{N-l, 1+d+l}
    \right).\\
\end{align*}
In order to properly define our problem as a QUBO problem, we need to put the loss function in the following form 
\[
    L = X^T Q X,
\]
where $M \in \mathbb{N}$, $X \in \left\{0,1 \right\}^M$, $Q \in \mathcal{M}_{M,M}\left(\left\{0, 1\right\}\right)$.

\noindent As such, let us define $\varphi  : \mathbb{N} \times \mathbb{N} \to \mathbb{N}$ such that 
\[
\forall i \in \llbracket 1, N \rrbracket
\quad 
\forall j \in \llbracket 1, N \rrbracket
\quad
\varphi \left(i,j\right) = N(i-1) + j,
\]
and let $X = (X_k)_{k \in \llbracket 1, N^2 \rrbracket}$ such that 
\[
\forall i \in \llbracket 1, N \rrbracket
\quad 
\forall j \in \llbracket 1, N \rrbracket
\quad 
X_{\varphi \left(i, j\right)} = x_{i,j}.
\]
We now have an appropriate QUBO problem.

\newpage
\subsection{Implementation}
\noindent We will now use the Fixstars Amplify API and Python to solve the N-queens problem with the above QUBO model. 
Thankfully, the Fixstars Amplify API auto-generates the penalty function from the constraints we have defined earlier.
As such, we do not need to properly define the matrix $Q$.  

\noindent Here is our Python code :

\begin{quote}
\begin{verbatim}
# Environment variable dependency
import os
from dotenv import load_dotenv

# Amplify dependencies
from amplify import VariableGenerator, AmplifyAEClient, ConstraintList
from amplify import equal_to, less_equal, solve

# Import environment variables 
load_dotenv()
token = os.getenv("FIXSTARS_TOKEN")

# Global variables declaration
N = 10  

# Board initialization
gen = VariableGenerator()
board = gen.array("Binary", shape=(N, N))

# Constraints initialization
constraints = ConstraintList()

# Row constraints 
for i in range(0,N):
    row_sum = 0
    for j in range(0,N):
        row_sum += board[i,j]
    constraints += equal_to(row_sum, 1)

# Column constraints 
for j in range(0,N):
    col_sum = 0
    for i in range(0,N):
        col_sum += board[i,j]
    constraints += equal_to(col_sum, 1)

# Diagonal constraints
for d in range(0, N):
    diag_sum = 0
    for k in range(0, N-d):
        diag_sum += board[k,k+d]
    constraints += less_equal(diag_sum, 1)

for d in range(1, N):
    diag_sum = 0
    for k in range(0, N-d):
        diag_sum += board[k+d,k]
    constraints += less_equal(diag_sum, 1)

for d in range(0, N):
    diag_sum = 0
    for k in range(0, N-d):
        diag_sum += board[N-d-k-1, k]
    constraints += less_equal(diag_sum, 1)

for d in range(1, N):
    diag_sum = 0
    for k in range(0, N-d):
        diag_sum += board[N-k-1,k+d]
    constraints += less_equal(diag_sum, 1)

model = constraints

# Initializing and calling the client solver
client = AmplifyAEClient()
client.token = token
client.parameters.time_limit_ms = 1000    # Set run time to 10000 ms

print("Calling solver ...")
result = solve(model, client)
best = result.best

print(f"Execution time: {result.execution_time} seconds")
print(f"Best solution :\n{board.evaluate(result.best.values)}")
\end{verbatim}
\end{quote}

\newpage
\subsection{Results}
By querying multiple requests to the server for different values of $N$, we get the following execution times :
\begin{center}
\includegraphics[width=0.5\textwidth]{ressources/qubo_data.png}
\captionof{figure}{Execution time of the QUBO model for different values of $N$}
\end{center}
We can also observe an exponential growth as $N$ grows larger.
Here, it is not computational power which does not allow us to look at cases where $N \geq 91$, but it 
is the amount of variables which blocks us. Indeed, Fixstars API is a service with different subscription tiers.
For $N > 90$, the number of variables exceeds the maximum job size of 8192. 
Performance-wise, our model is similar to the 1-queen problem for $N \leq 40$. 
These values are also quite low, being expressed in microseconds unlike the previous model.

\section{Comparing different models}

\subsection{Reminder - Baseline model}
Unlike our previous model, here we consider $N$ different integer variables of value ranging from 1 to $N$. 
Let us consider for $i \in \llbracket 1, N \rrbracket$, $Q_i \in \llbracket 1, N \rrbracket$ be the row the queen in column $k$ is placed.
This problem formulation already fits the row constraint we developed previously. To translate the column constraint, 
here all variables must be different from one another, or 
\begin{align*}
    \forall i \in \llbracket 1, N \rrbracket \quad \forall j \in \llbracket 1, N \rrbracket \quad i \neq j \implies Q_i \neq Q_j. \\
\end{align*}
As for the diagonal constraints, they become : 
\begin{align*}
    \forall i \in \llbracket 1, N \rrbracket \quad \forall j \in \llbracket 1, N \rrbracket \quad i \neq j \implies Q_i + i \neq Q_j + j \\
    \forall i \in \llbracket 1, N \rrbracket \quad \forall j \in \llbracket 1, N \rrbracket \quad i \neq j \implies Q_i - i \neq Q_j - j \\
\end{align*}

\newpage
\subsection{Implementation of the baseline model}
The lecture slide uses this \href{https://docs.minizinc.dev/en/2.5.5/downloads/nqueens.mzn}{MiniZinc example}, 
available from the MiniZinc documentation.
\begin{quote}
\begin{verbatim}
int: n;
array [1..n] of var 1..n: q; % queen in column i is in row q[i]

include "alldifferent.mzn";

constraint alldifferent(q);                       % distinct rows
constraint alldifferent([ q[i] + i | i in 1..n]); % distinct diagonals
constraint alldifferent([ q[i] - i | i in 1..n]); % upwards+downwards

% search
solve :: int_search(q, first_fail, indomain_min)
      satisfy;
output [ if fix(q[j]) == i then "Q" else "." endif ++
         if j == n then "\n" else "" endif | i,j in 1..n]        
\end{verbatim}
\end{quote}
With a few iterations of this implementation, we get the following execution times : 
\begin{center}
    \includegraphics[width=0.5\textwidth]{ressources/baseline_data.png}
    \captionof{figure}{Execution time of the baseline model for different values of $N$}
\end{center}
We can observe the same overall figure of an exponential increase as $N$ gets larger. 
However, here, for $N \leq 100$, we can observe fluctuations. Certain cases are more complex than others.
This can be attributed to the solver not taking the best path first and thus being longer for some cases more than others.
This model can go up to $N=400$ with only 1.4s of execution time.

\noindent
Since all models follow an exponential growth, we will use log scale to compare models with one another.

\subsection{MiniZinc models}

\begin{center}
    \includegraphics[width=0.5\textwidth]{ressources/minizinc_vs_baseline_log.png}
    \captionof{figure}{Comparison of both MiniZinc models on a log scale}
\end{center}

The boolean variable MiniZinc model performs way worse than the integer variable MiniZinc model. 
Indeed, it is hard to have results for $N \geq 25$ for the boolean variable model due to the long execution times
whereas the integer variable model computes for up to $N=400$.

Differences between both models lie in the choice of variables. The choice to use integer variables already implements the row 
constraint. The column constraint becomes a simple difference check between all variables instead of computing a heavy sum of $\mathcal{O}\left(N\right)$
for each variable and thus a total cost of $\mathcal{O}\left(N^2\right)$. Furthermore instead of using $N^2$ variables, we only need to use $N$ variables.

This comparison shows the importance of well defining one's model for optimization problems by trying to 
imply as many constraints as possible in the definition of the variables.

\subsection{Comparing the QUBO model with the integer variable MiniZinc model}

\begin{center}
    \includegraphics[width=0.5\textwidth]{ressources/qubo_vs_baseline_log.png}
    \captionof{figure}{Comparison of QUBO model to baseline on a log scale}
\end{center}

As for the QUBO model, although we cannot have values for the greater values of $N$ like the MiniZinc baseline model due to 
the limitations of the Fixstars API, we can already observe that the values for $N=90$ are similar to those for $N=300$ of the MiniZinc baseline model.

An interesting aspect of the QUBO model though, is that for the cases where $N$ is small, it outperforms the MiniZinc model.
This is probably because the servers owned by Fixstars are tuned to perform this kind of computation instead of running the MiniZinc models on one's own computer.

By applying what we saw from the analysis of the MiniZinc models, one might wonder if adapting the integer variable model to QUBO might improve performance, perhaps by using Unary encoding 
of the integer variables. Although it would decrease the number of variables by a small margin with $N$ integer variables encoded each by $N-1$ boolean variables thus $N\left(N-1\right)$ boolean variables in total, 
the complexity of the constraints would not get better but would get worse since we also have to add constraints to keep the encoding of the integer variables.

\section{Conclusion}
In this report, we have introduced 2 boolean variable models to solve the $N$-queens problem : a MiniZinc model and a QUBO model. We used an integer variable MiniZinc model as a baseline model to compare execution time.
Concerning the MiniZinc models, we can see the importance of a well defined model considering that one can compute solutions up to $N=400$ whereas the other one struggles at $N\geq 25$. From these 2 models, we can also see the importance
of how the number of variables and constraints can hinder a model meant to solve a constraint optimization problem. The baseline model shows that defining the variables such that we simplify the constraints and even imply some 
just by the definition of the variables can greatly improve the performance of a model.
As for the QUBO model, we can see that QUBO is way more efficient than the boolean variable model in MiniZinc, as it is able to go up to $N=90$ at least. But it also shows the weakness of QUBO as even though it is faster for such computation, 
we do not have the same freedom in defining our variables and thus simplifying our model for better efficiency. As such, the integer variable MiniZinc model still outperforms our QUBO model.

\section{Resources}
\begin{itemize}
    \item Project source code : \href{https://github.com/Gillan0/n_queens_optimization}{https://github.com/Gillan0/n\_queens\_optimization}
    \item MiniZinc : \href{https://www.minizinc.org/}{https://www.minizinc.org/}
    \item Fixstars : \href{https://amplify.fixstars.com/en/}{https://amplify.fixstars.com/en/}
\end{itemize}

\end{document}